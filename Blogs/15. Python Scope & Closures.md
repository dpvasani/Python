# ğŸ§  Python Scope & Closures â€“ Zero to Hero Guide

---

## ğŸ§© 1. What is Scope in Python?

### ğŸ“Œ **Definition**:

Scope refers to **which part of the program can access a variable**.

### ğŸ—‚ï¸ Types of Scope:

Python uses the **LEGB Rule** for scope resolution:

| ğŸ”¤ Scope          | ğŸ’¡ Description                                       |
| ----------------- | ---------------------------------------------------- |
| **L** (Local)     | Inside the current function                          |
| **E** (Enclosing) | Inside any enclosing function (for nested functions) |
| **G** (Global)    | At the top-level of the module                       |
| **B** (Built-in)  | Pythonâ€™s built-in names (like `len`, `range`, etc)   |

---

## ğŸ“¦ 2. Local vs Global Variables

```python
x = 10  # ğŸŒ Global variable

def example():
    x = 5  # ğŸ“ Local variable
    print(x)

example()   # Output: 5
print(x)    # Output: 10
```

ğŸ” Python uses **the nearest defined variable** by default.

---

## ğŸ”„ 3. The `global` Keyword

To modify a global variable inside a function:

```python
count = 0

def increment():
    global count
    count += 1

increment()
print(count)  # Output: 1
```

âš ï¸ Avoid overusing `global`. It makes code harder to debug ğŸ”§

---

## ğŸ§­ 4. Nested Functions & Enclosing Scope

```python
def outer():
    message = "Hello"

    def inner():
        print(message)

    inner()

outer()
```

âœ”ï¸ `inner()` can access `message` from `outer()` even though it's not defined inside it.

This is **Enclosing Scope**!

---

## ğŸ¯ 5. The `nonlocal` Keyword

`nonlocal` lets us **modify a variable from the enclosing function**.

```python
def outer():
    count = 0

    def inner():
        nonlocal count
        count += 1
        print("Inner count:", count)

    inner()
    print("Outer count:", count)

outer()
```

### ğŸ“Œ Output:

```
Inner count: 1
Outer count: 1
```

---

## ğŸ§™â€â™‚ï¸ 6. What is a Closure?

A **closure** is a function that **remembers values** from its **enclosing lexical scope**, even if that scope is no longer active.

### ğŸ“¦ Closure = Function + Enclosing State

---

### ğŸ§ª Example of a Closure:

```python
def make_multiplier(x):
    def multiplier(n):
        return x * n
    return multiplier

times3 = make_multiplier(3)
print(times3(5))  # Output: 15
```

ğŸ” Even though `x` is gone (function `make_multiplier` has finished), `times3` still **remembers** that `x = 3`. Thatâ€™s closure.

---

## ğŸ” 7. How to Identify a Closure?

### âœ… A function must:

1. Be **nested inside another function**
2. **Use a variable** from the enclosing function
3. Be **returned from the outer function**

---

## ğŸ§° 8. Use Cases of Closures

| ğŸ§  Use Case            | ğŸ“„ Description                             |
| ---------------------- | ------------------------------------------ |
| **Encapsulation**      | Hide variables from global scope           |
| **Callback functions** | Useful in decorators, UI events            |
| **Factory functions**  | Functions that return customized functions |

---

## ğŸ§ª Real-life Analogy:

Imagine a chef ğŸ‘¨â€ğŸ³ (inner function) trained in a specific kitchen ğŸ¡ (outer function). Even if the kitchen closes, the chef retains the recipe ğŸ“. That recipe is the closure.

---

## âš™ï¸ 9. Advanced Closure Behavior

Closures maintain **state** without using classes:

```python
def counter():
    count = 0
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

c = counter()
print(c())  # 1
print(c())  # 2
```

Each call remembers the updated `count`. Thatâ€™s closure magic âœ¨

---

## ğŸš« Common Pitfall

### âŒ Problem:

```python
def bad_closures():
    funcs = []
    for i in range(3):
        def inner():
            return i
        funcs.append(inner)
    return funcs

closures = bad_closures()
print([f() for f in closures])  # âŒ Output: [2, 2, 2]
```

### âœ… Fix using default arguments:

```python
def good_closures():
    funcs = []
    for i in range(3):
        def inner(i=i):  # ğŸ› ï¸ capture i at that time
            return i
        funcs.append(inner)
    return funcs

closures = good_closures()
print([f() for f in closures])  # âœ… Output: [0, 1, 2]
```

---

## ğŸ§  10. Summary (Zero â¡ï¸ Hero)

| Concept       | Learnings                                        |
| ------------- | ------------------------------------------------ |
| ğŸ” Scope      | LEGB Rule: Local â†’ Enclosing â†’ Global â†’ Built-in |
| ğŸ§ª Local      | Variable inside function                         |
| ğŸŒ Global     | Variable outside all functions                   |
| ğŸ§© Enclosing  | For nested functions                             |
| ğŸ”“ `global`   | Modify global variable from inside               |
| ğŸ”„ `nonlocal` | Modify enclosing variable in nested function     |
| ğŸ§  Closure    | Function + enclosed state                        |
| ğŸ› ï¸ Use       | Factory functions, decorators, encapsulation     |

---

## ğŸ“š Bonus: Python `inspect` closure

To inspect closures:

```python
def outer():
    x = 10
    def inner():
        return x
    return inner

func = outer()
print(func.__closure__[0].cell_contents)  # Output: 10
```

---

## âœ… Final Thought:

Closures are **powerful**, **clean**, and **memory-efficient** tools in Python ğŸ”¥
They allow you to write flexible code without needing to create classes every time ğŸ§°

---

