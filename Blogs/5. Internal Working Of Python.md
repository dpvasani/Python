# ğŸ” Internal Working of Python: Copy, References & Memory Management

## ğŸ§  1. Understanding Python Variables â€“ Itâ€™s all about **References**

In Python, **everything is an object**, and **variables are just references (pointers)** to those objects.

```python
a = 10
b = a
```

Here:

* `a` points to the object `10`.
* `b` **also points to** the same object `10`.

ğŸ§ª Both `a is b` and `a == b` are `True`.

ğŸ‘‰ **Integers are immutable**, so any change results in a new object.

---

## ğŸ”¢ 2. Reference Counting â€“ Python's ğŸ§¹ Memory Manager

Python uses **reference counting** for memory management:

```python
import sys
a = []
print(sys.getrefcount(a))  # usually prints 2 due to temp reference in function call
```

* The count increases when a new reference is made.
* Decreases when a reference is deleted (`del` or re-assignment).
* When count hits **zero**, ğŸ§¹ Python's **Garbage Collector** destroys the object.

---

## ğŸ§¾ 3. Mutable vs Immutable â€“ The DNA ğŸ§¬ of Behavior

| Type       | Mutable | Example              |
| ---------- | ------- | -------------------- |
| int, str   | âŒ No    | `a = 10`, `s = "hi"` |
| list, dict | âœ… Yes   | `lst = [1, 2]`       |

```python
a = [1, 2]
b = a
b.append(3)
print(a)  # [1, 2, 3] â¡ï¸ both `a` and `b` point to the same object!
```

---

## âœ‚ï¸ 4. Slicing â€“ Copy or Not? ğŸ¤”

### âœ… Immutable types (like `str`, `tuple`) always return a new object.

```python
s1 = "hello"
s2 = s1[:]
print(s1 is s2)  # False
```

### âš ï¸ For mutable types (like `list`), slicing **creates a shallow copy**.

```python
lst1 = [1, 2, 3]
lst2 = lst1[:]
print(lst1 is lst2)  # False (new list)
```

But beware! âš ï¸

```python
nested = [[1, 2], [3, 4]]
shallow = nested[:]
shallow[0][0] = 999
print(nested)  # [[999, 2], [3, 4]]
```

ğŸ‘‰ The inner lists are still **shared**!

---

## ğŸ”„ 5. Copying â€“ Identity Crisis ğŸ˜…

### ğŸ”¹ **Assignment (`=`)**

Just creates another reference to the **same** object:

```python
a = [1, 2]
b = a
b.append(3)
print(a)  # [1, 2, 3]
```

---

### ğŸ”¹ **Shallow Copy (`copy.copy()`, `[:]`)**

* Creates a **new outer object**.
* **Inner objects are still shared**.

```python
import copy
original = [[1, 2], [3, 4]]
shallow = copy.copy(original)
shallow[0][0] = 100
print(original)  # [[100, 2], [3, 4]]
```

---

### ğŸ”¹ **Deep Copy (`copy.deepcopy()`)**

Creates a full copy â€” outer + inner objects:

```python
deep = copy.deepcopy(original)
deep[0][0] = 999
print(original)  # [[1, 2], [3, 4]]
```

âœ… Changes in `deep` donâ€™t affect `original`.

---

## ğŸ§ª 6. Edge Case Behavior

### ğŸ¯ Int Behavior

```python
a = 256
b = 256
print(a is b)  # True âœ… (cached small ints)

a = 257
b = 257
print(a is b)  # False âŒ (new objects beyond cache range)
```

### ğŸ¯ List Behavior

```python
lst = [1, 2, 3]
copied = lst[:]
copied.append(4)
print(lst)      # [1, 2, 3]
print(copied)   # [1, 2, 3, 4]
```

But...

```python
a = [[1], [2]]
b = a[:]
b[0].append(999)
print(a)  # [[1, 999], [2]] â€” inner list is shared!
```

---

## ğŸ§ª 7. Copy inside Functions

```python
def modify(lst):
    lst.append(99)

a = [1, 2]
modify(a)
print(a)  # [1, 2, 99] â€” passed by reference!
```

If you want to **avoid side-effects**, pass a **copy**:

```python
modify(a[:])  # or use copy.deepcopy(a)
```

---

## ğŸš€ Tips to Master Internals

* Use `id()` to track object identity.
* Use `sys.getrefcount()` to debug references.
* Use `is` to check **object identity**, not equality.
* Use `copy.deepcopy()` to fully isolate data.
* Slice carefully with nested structures!

---

## ğŸ§  Summary Table

| Operation          | Type of Copy | Outer Object | Inner Objects | Use Case        |
| ------------------ | ------------ | ------------ | ------------- | --------------- |
| `a = b`            | No copy      | Same         | Same          | Share reference |
| `a[:]`             | Shallow copy | New          | Same          | Quick copy      |
| `copy.copy(a)`     | Shallow copy | New          | Same          | Like slice      |
| `copy.deepcopy(a)` | Deep copy    | New          | New           | Full isolation  |

---

## ğŸ’¡ Final Thoughts

* In Python, **knowing how objects and references work** is ğŸ”‘ to writing safe, efficient code.
* Itâ€™s not about copying values â€” it's about understanding **who points to what** ğŸ”.
* Always test for `is` vs `==`, especially with mutable types!

---
