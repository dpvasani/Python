# ğŸ§  Python: Mutable vs Immutable Explained ğŸš€

---

## ğŸ” What is Mutability in Python?

ğŸ§© In simple terms:

* **Mutable** = Can be **changed** after creation âœ…
* **Immutable** = **Cannot be changed** once created ğŸš«

---

## ğŸ” Immutable Objects (ğŸš« Cannot be changed)

| Type        | Examples               |
| ----------- | ---------------------- |
| `int`       | `1`, `42`              |
| `float`     | `3.14`, `0.99`         |
| `str`       | `"hello"`, `'world'`   |
| `tuple`     | `(1, 2)`, `('a', 'b')` |
| `bool`      | `True`, `False`        |
| `frozenset` | `frozenset({1, 2, 3})` |

### ğŸ”’ Example:

```python
>>> x = 10
>>> id(x)
140734294843888

>>> x += 1  # creates a new object!
>>> id(x)
140734294843920  # Different ID
```

ğŸ§  `int` is immutable â€” modifying it actually creates a **new object**.

---

## ğŸ”„ Mutable Objects (âœ… Can be changed)

| Type           | Examples                   |
| -------------- | -------------------------- |
| `list`         | `[1, 2, 3]`                |
| `dict`         | `{"a": 1, "b": 2}`         |
| `set`          | `{1, 2, 3}`                |
| `bytearray`    | `bytearray(b"abc")`        |
| `Custom Class` | With modifiable attributes |

### ğŸ”§ Example:

```python
>>> nums = [1, 2, 3]
>>> id(nums)
139800123

>>> nums.append(4)
>>> nums
[1, 2, 3, 4]

>>> id(nums)
139800123  # Same ID â€“ changed in place!
```

---

## ğŸ§ª Deeper: Why does this matter?

### âœ… Mutable:

You can change the object without changing its identity (memory address)

### âŒ Immutable:

Any "change" creates a **new object**

---

## âš ï¸ Common Pitfall with Mutable Default Args

```python
def append_num(num, nums=[]):  # Bad! ğŸ˜±
    nums.append(num)
    return nums

>>> append_num(1)
[1]
>>> append_num(2)
[1, 2]  # Unexpected! ğŸ˜³
```

âœ… **Fix it:**

```python
def append_num(num, nums=None):
    if nums is None:
        nums = []
    nums.append(num)
    return nums
```

---

## ğŸ§  Immutables inside Mutables

```python
a = [1, 2, (3, 4)]
a[2] = (5, 6)  # âœ… OK, can change the *element*
```

But the tuple `(3, 4)` itself can't be changed.

---

## ğŸ” Copying and Mutability

### `=`, `copy()`, and `deepcopy()`

```python
import copy

a = [1, 2, [3, 4]]
b = copy.copy(a)       # Shallow copy
c = copy.deepcopy(a)   # Deep copy

a[2][0] = 99
print(b)  # [1, 2, [99, 4]]
print(c)  # [1, 2, [3, 4]]
```

---

## âœ… Use Cases

| Scenario                  | Prefer                                    |
| ------------------------- | ----------------------------------------- |
| Configuration keys        | Immutable (`tuple`)                       |
| Changing datasets         | Mutable (`list`, `dict`)                  |
| Hashing in sets/dicts     | Must be immutable (`str`, `int`, `tuple`) |
| Memory efficiency (fixed) | Immutable                                 |
| Avoiding side-effects     | Immutable                                 |

---

## ğŸ§ª How to Check If Object is Mutable?

```python
>>> a = [1, 2]
>>> id_before = id(a)
>>> a.append(3)
>>> id_before == id(a)
True  # âœ… Mutable

>>> s = "hello"
>>> id(s) == id(s + " world")
False  # ğŸš« Immutable
```

---

## ğŸ’¡ Pro Tips

ğŸ§  Strings are immutable â€” every `+`, `replace()`, `strip()` returns a **new string**
ğŸ” Tuples are immutable, but **can contain mutables**
ğŸ§ª Use `id()` to track object identity
âœ… Use `frozenset` when you want an immutable version of `set`
ğŸ“Œ Use `tuple` over `list` for fixed collections (e.g., coordinates)

---

## ğŸ“Œ Summary Table

| Type        | Mutable? | Example         | Notes                       |
| ----------- | -------- | --------------- | --------------------------- |
| `int`       | âŒ        | `x = 1`         | Any math creates new object |
| `str`       | âŒ        | `s = "abc"`     | All ops return new string   |
| `list`      | âœ…        | `l = [1, 2]`    | Use for dynamic collections |
| `dict`      | âœ…        | `{"a": 1}`      | Best for key-value pairs    |
| `tuple`     | âŒ        | `(1, 2)`        | Use when fixed and ordered  |
| `set`       | âœ…        | `{1, 2}`        | Unordered, no duplicates    |
| `frozenset` | âŒ        | `frozenset({})` | Immutable version of set    |

---

# ğŸ“Š Mutable vs Immutable Types in Python

|  ğŸ”¢ Sr | ğŸ“¦ Data Type   | ğŸ”„ Mutable? | ğŸ§ª Example               | ğŸ“ Notes / Remarks                             |
| -----: | -------------- | ----------- | ------------------------ | ---------------------------------------------- |
|    1ï¸âƒ£ | `int`          | âŒ No        | `x = 10`                 | Immutable â€“ any operation creates a new object |
|    2ï¸âƒ£ | `float`        | âŒ No        | `pi = 3.14`              | Same as `int` â€“ immutable                      |
|    3ï¸âƒ£ | `bool`         | âŒ No        | `is_on = True`           | Internally treated as integers                 |
|    4ï¸âƒ£ | `str`          | âŒ No        | `s = "hello"`            | Every change returns a new string              |
|    5ï¸âƒ£ | `tuple`        | âŒ No        | `t = (1, 2, 3)`          | Immutable, but can contain mutables            |
|    6ï¸âƒ£ | `frozenset`    | âŒ No        | `fs = frozenset([1, 2])` | Immutable version of `set`                     |
|    7ï¸âƒ£ | `bytes`        | âŒ No        | `b = b'abc'`             | Immutable sequence of bytes                    |
|    8ï¸âƒ£ | `list`         | âœ… Yes       | `l = [1, 2, 3]`          | Supports append, pop, etc.                     |
|    9ï¸âƒ£ | `dict`         | âœ… Yes       | `d = {"a": 1}`           | Keys must be immutable                         |
|     ğŸ”Ÿ | `set`          | âœ… Yes       | `s = {1, 2, 3}`          | Unordered, no duplicates, mutable              |
| 1ï¸âƒ£1ï¸âƒ£ | `bytearray`    | âœ… Yes       | `ba = bytearray(b"abc")` | Mutable version of bytes                       |
| 1ï¸âƒ£2ï¸âƒ£ | `custom class` | âœ… Yes\*     | `class A: pass`          | Mutable by default unless overridden           |

---

## ğŸ§  Key Points

* â— You **canâ€™t** use mutable types as keys in `dict` or elements in `set`.
* âœ… Immutable types are **hashable** and used in sets/dicts as keys.
* ğŸ” Mutable objects allow **in-place** changes â€” great for performance but risky in shared environments.

---
